---
title: 盘点Vue3新特性
date: 2020-11-18 21:51:53
permalink: /pages/768195/
categories: 
  - 前端
  - Vue文章
tags: 
  - Vue3.0
author: 
  name: fanfan
  link: https://github.com/fanquan/UIFan
---

# 盘点Vue3新特性
## 前言
Vue3.0 在今年9月正式发布了，也有许多小伙伴都热情的拥抱Vue3.0。由于我当时负责的项目没有升级3.0的计划，所以自己一直都没有去深入的学习。but~, 突然公司要新做一个项目，早上起来发现自己居然被拉进了这个项目组，项目技术栈还是Vue3.0, 所以就不得不学习一下Vue3.0了。
首先我大概去了解了一下 Vue3.0 主要的一些特性：

![](http://imgcdn.mashanghudong.cn/blog/vue/vue3-all.jpg)

## 为什么要升级Vue3
使用Vue2.x的小伙伴都熟悉，Vue2.x中所有数据都是定义在`data`中，方法定义在`methods`中的，并且使用`this`来调用对应的数据和方法。
那Vue3.x中就可以不这么玩了， 具体怎么玩我们后续再说， 先说一下Vue2.x版本这么写有什么缺陷，所有才会进行升级变更的。

### 回顾Vue2.x实现加减

```javascript
<template>
  <div class="homePage">
    <p>count: {{ count }}</p>
    <p>倍数： {{ multiple }}</p>
    <div>
        <button style="margin-right:10px" @click="increase">加1</button>
        <button @click="decrease">减一</button>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },

  computed: {
    multiple() {
      return 2 * this.count;
    },
  },

  methods: {
    increase() {
      this.count++;
    },
    decrease() {
      this.count++;
    },
  },
};
</script>
```
上面代码只是实现了对`count`的加减以及显示倍数， 就需要分别在data、methods、computed中进行操作，当我们增加一个需求，就会出现下图的情况：

![](http://imgcdn.mashanghudong.cn/blog/vue/vue3_texing.png)

当我们业务复杂了就会大量出现上面的情况， 随着复杂度上升，就会出现这样一张图， 每个颜色的方块表示一个功能：

![](http://imgcdn.mashanghudong.cn/blog/vue/vue3_texing1.jpg)

甚至一个功能还有会依赖其他功能，全搅合在一起。

当这个组件的代码超过几百行时，这时增加或者修改某个需求， 就要在data、methods、computed以及mounted中反复的跳转，这其中的的痛苦写过的都知道。

那我们就想啊， 如果可以按照逻辑进行分割，将上面这张图变成下边这张图，是不是就清晰很多了呢, 这样的代码可读性和可维护性都更高：

![](http://imgcdn.mashanghudong.cn/blog/vue/vue3_texing2.jpg)

那么vue2.x版本给出的解决方案就是Mixin, 但是使用Mixin也会遇到让人苦恼的问题：
1. 命名冲突问题
2. 不清楚暴露出来的变量的作用
3. 逻辑重用到其他 component 经常遇到问题

关于上面经常出现的问题我就不一一举例了，使用过的小伙伴多多少少都会遇到。文章的重点不是Mixin,如果确实想知道的就留言啦~

所以，我们Vue3.x就推出了`Composition API`主要就是为了解决上面的问题，将零散分布的逻辑组合在一起来维护，并且还可以将单独的功能逻辑拆分成单独的文件。
接下来我们就重点认识`Composition API`。

## Composition API


![](http://imgcdn.mashanghudong.cn/blog/vue/vue3_texing4.jpg)

### setup
setup 是Vue3.x新增的一个选项， 他是组件内使用 `Composition API`的入口。

**setup执行时机**
我在学习过程中看到很多文章都说setup 是在 `beforeCreate`和`created`之间， 这个结论是错误的。
实践是检验真理的唯一标准， 于是自己去检验了一下：
```javascript
export default defineComponent ({
    beforeCreate() {
        console.log("----beforeCreate----");
    },
    created() {
        console.log("----created----");
    },
    setup() {
        console.log("----setup----");
    },
})
```

![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_texing888.jpg)

setup 执行时机是在beforeCreate之前执行，详细的可以看后面生命周期讲解。

::: warning
由于在执行`setup` 时尚未创建组件实例，因此在 `setup` 选项中没有 `this`。
:::

#### setup 参数
使用`setup`时，它接受两个参数：
- 1.props: 组件传入的属性
- 2.context



setup中接受的`props`是响应式的， 当传入新的props 时，会及时被更新。由于是响应式的， 所以**不可以使用ES6解构**，解构会消除它的响应式。

**错误代码示例**， 这段代码会让props不再支持响应式：
```javascript
// demo.vue
export default defineComponent ({
    setup(props, context) {
        const { name } = props
        console.log(name)
    },
})
```
那在开发中我们**想要使用解构，还能保持`props`的响应式**，有没有办法解决呢？大家可以思考一下，在下边`toRefs`学习的地方为大家解答。

接下来我们来说一下`setup`接受的第二个参数`context`，我们前面说了`setup`中不能访问Vue2中最常用的`this`对象，所以`context`中就提供了`this`中最常用的三个属性：`attrs`、`slot` 和`emit`，分别对应Vue2.x中的 `$attr`属性、`slot`插槽 和`$emit`发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。


### 2. reactive、ref与toRefs
在vue2.x中， 定义数据都是在`data`中， 但是Vue3.x 可以使用`reactive`和`ref`来进行数据定义。

那么`ref`和`reactive`他们有什么区别呢？分别什么时候使用呢？说到这里，我又不得不提一下，看到很多网上不上文章说(`reactive`用于处理对象的双向绑定，`ref`则处理js基础类型的双向绑定)。我其实不太赞同这样的说法，这样很容易初学者认为`ref`就能处理js基本类型， 比如`ref`也是可以定义对象的双向绑定的啊， 上段代码：
```javascript
 setup() {
    const obj = ref({count:1, name:"张三"})
    setTimeout(() =>{
        obj.value.count = obj.value.count + 1
        obj.value.name = "李四"
    }, 1000)
    return{
        obj
    }
  }
```
我们将`obj.count`和`obj.name`绑定到页面上也是可以的；但是`reactive`函数确实可以代理一个对象， 但是不能代理基本类型，例如字符串、数字、boolean等。

接下来使用代码展示一下`ref`、`reactive`的使用：

![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_texing999.png)

运行效果:

![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_texing1.gif)

上面的代码中，我们绑定到页面是通过`user.name`,`user.age`； 这样写感觉很繁琐，我们能不能直接将`user`中的属性解构出来使用呢?答案是不能直接对`user`进行结构， 这样会消除它的响应式， 这里就和上面我们说`props`不能使用ES6直接解构就呼应上了。那我们就想使用解构后的数据怎么办，解决办法就是**使用`toRefs`**。

toRefs用于将一个reactive对象转化为属性全部为ref对象的普通对象。具体使用方式如下：
```html
<template>
  <div class="homePage">
    <p>第 {{ year }} 年</p>
    <p>姓名： {{ nickname }}</p>
    <p>年龄： {{ age }}</p>
  </div>
</template>

<script>
import { defineComponent, reactive, ref ,toRefs} from "vue";
export default defineComponent({
  setup() {
    const year = ref(0);
    const user = reactive({ nickname: "xiaofan", age: 26, gender: "女" });
    setInterval(() =>{
        year.value ++
        user.age ++
    }, 1000)
    return {
        year,
        // 使用reRefs
        ...toRefs(user)
    }
  },
});
</script>
```

<!-- ![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_texing1000.png) -->

### 简单对比vue2.x与vue3.x响应式
其实在Vue3.x 还没有发布bate的时候， 很火的一个话题就是`Vue3.x 将使用Proxy 取代Vue2.x 版本的 Object.defineProperty`。

没有无缘无故的爱，也没有无缘无故的恨。为何要将`Object.defineProperty`换掉呢，咋们可以简单聊一下。

我刚上手Vue2.x的时候就经常遇到一个问题，数据更新了啊，为何页面不更新呢？ 什么时候用`$set`更新，什么时候用`$forceUpdate`强制更新，你是否也一度陷入困境。后来的学习过程中开始接触源码，才知道一切的根源都是 `Object.defineProperty`。

对这块想要深入了解的小伙伴可以看这篇文章 [为什么Vue3.0不再使用defineProperty实现数据监听？](https://www.infoq.cn/article/sPCMAcrdAZQfmLbGJeGr)
要详细解释又是一篇文章，这里就简单对比一下`Object.defineProperty` 与Proxy

1. `Object.defineProperty`只能劫持对象的属性， 而Proxy是直接代理对象
   
由于`Object.defineProperty`只能劫持对象属性，需要遍历对象的每一个属性，如果属性值也是对象，就需要递归进行深度遍历。但是Proxy直接代理对象， 不需要遍历操作

2. `Object.defineProperty`对新增属性需要手动进行`Observe`

因为`Object.defineProperty`劫持的是对象的属性，所以新增属性时，需要重新遍历对象， 对其新增属性再次使用`Object.defineProperty`进行劫持。也就是Vue2.x中给数组和对象新增属性时，需要使用`$set`才能保证新增的属性也是响应式的, `$set`内部也是通过调用`Object.defineProperty`去处理的。


### 生命周期钩子
我们可以直接看生命周期图来认识都有哪些生命周期钩子(图片是根据官网翻译后绘制的)：

![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_life.png)

从图中我们可以看到Vue3.0新增了`setup`，这个在前面我们也详细说了， 然后是将Vue2.x中的`beforeDestroy`名称变更成`beforeUnmount`; `destroyed` 表更为 `unmounted`，作者说这么变更纯粹是为了更加语义化，因为一个组件是一个`mount`和`unmount`的过程。其他Vue2中的生命周期仍然保留。


上边`生命周期图`中并没包含全部的生命周期钩子， 还有其他的几个， 全部生命周期钩子如图所示：
![](http://fe-inter-1257802320.cos.ap-beijing.myqcloud.com/blog/vue/vue3_texing_duib.jpg)


我们可以看到`beforeCreate`和`created`被`setup`替换了（但是Vue3中你仍然可以使用， 因为Vue3是向下兼容的， 也就是你实际使用的是vue2的）。其次，钩子命名都增加了`on`; Vue3.x还新增用于调试的钩子函数`onRenderTriggered`和`onRenderTricked`

下面我们简单使用几个钩子， 方便大家学习如何使用，Vue3.x中的钩子是需要从vue中导入的：
```JavaScript
import { defineComponent, onBeforeMount, onMounted, onBeforeUpdate,onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked, onRenderTriggered
} from "vue";

export default defineComponent({
  // beforeCreate和created是vue2的
  beforeCreate() {
    console.log("------beforeCreate-----");
  },
  created() {
    console.log("------created-----");
  },
  setup() {
    console.log("------setup-----");

    // vue3.x生命周期写在setup中
    onBeforeMount(() => {
      console.log("------onBeforeMount-----");
    });
    onMounted(() => {
      console.log("------onMounted-----");
    });
    // 调试哪些数据发生了变化
    onRenderTriggered((event) =>{
        console.log("------onRenderTriggered-----",event);
    })
  },
});
```
关于生命周期相关的内容就介绍到这里，下面我们介绍一下Vue3.x中`watch`有什么不同。

### watch 与 watchEffect 的用法
> watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是惰性的，也就是说仅在侦听的源数据变更时才执行回调。
```
watch(source, callback, [options])
```
参数说明：
- source:可以支持string,Object,Function,Array; 用于指定要侦听的响应式变量
- callback: 执行的回调函数
- options：支持deep、immediate 和 flush 选项。

接下来我会分别介绍这个三个参数都是如何使用的， 如果你对watch的使用不明白的请往下看：

#### 侦听reactive定义的数据
```javascript
import { defineComponent, ref, reactive, toRefs, watch } from "vue";
export default defineComponent({
  setup() {
    const state = reactive({ nickname: "xiaofan", age: 20 });

    setTimeout(() =>{
        state.age++
    },1000)

    // 修改age值时会触发 watch的回调
    watch(
      () => state.age,
      (curAge, preAge) => {
        console.log("新值:", curAge, "老值:", preAge);
      }
    );

    return {
        ...toRefs(state)
    }
  },
});
```
#### 侦听ref定义的数据
```javascript
const year = ref(0)

setTimeout(() =>{
    year.value ++ 
},1000)

watch(year, (newVal, oldVal) =>{
    console.log("新值:", newVal, "老值:", oldVal);
})
```

#### 侦听多个数据
上面两个例子中，我们分别使用了两个watch, 当我们需要侦听多个数据源时， 可以进行合并， 同时侦听多个数据：
```javascript
watch([() => state.age, year], ([curAge, preAge], [newVal, oldVal]) => {
    console.log("新值:", curAge, "老值:", preAge);
    console.log("新值:", newVal, "老值:", oldVal);
});
```

#### 侦听复杂的嵌套对象
我们实际开发中，复杂数据随处可见， 比如：
```javascript
const state = reactive({
    room: {
    id: 100,
    attrs: {
        size: "140平方米",
        type:"三室两厅"
    },
    },
});
watch(() => state.room, (newType, oldType) => {
    console.log("新值:", newType, "老值:", oldType);
}, {deep:true});
```
如果不使用第三个参数`deep:true`， 是无法监听到数据变化的。 

前面我们提到，**默认情况下，watch是惰性的**, 那什么情况下不是惰性的， 可以立即执行回调函数呢？ 其实使用也很简单， 给第三个参数中设置`immediate: true`即可。关于`flush`配置，还在学习，后期会补充

#### stop 停止监听
我们在组件中创建的`watch`监听，会在组件被销毁时自动停止。 如果在组件销毁之前我们想要停止掉某个监听， 可以调用`watch()`函数的返回值，操作如下：

```javascript
const stopWatchRoom = watch(() => state.room, (newType, oldType) => {
    console.log("新值:", newType, "老值:", oldType);
}, {deep:true});

setTimeout(()=>{
    // 停止监听
    stopWatchRoom()
}, 3000)
```

还有一个监听函数`watchEffect`,在我看来`watch`已经能满足监听的需求，为什么还要有`watchEffect`呢？ 虽然我没有get到它的必要性，但是还是要介绍一下`watchEffect`，首先看看它的使用和`watch`究竟有何不同。
```javascript
import { defineComponent, ref, reactive, toRefs, watchEffect } from "vue";
export default defineComponent({
  setup() {
    const state = reactive({ nickname: "xiaofan", age: 20 });
    let year = ref(0)

    setInterval(() =>{
        state.age++
        year.value++
    },1000)

    watchEffect(() => {
        console.log(state);
        console.log(year);
      }
    );

    return {
        ...toRefs(state)
    }
  },
});
```
执行结果首先打印一次`state`和`year`值； 然后每隔一秒，打印`state`和`year`值。

从上面的代码可以看出， 并没有像`watch`一样需要先传入依赖，`watchEffect`会自动收集依赖, 只要指定一个回调函数。在组件初始化时， 会先执行一次来收集依赖， 然后当收集到的依赖中数据发生变化时， 就会再次执行回调函数。所以总结对比如下：
1. watchEffect 不需要手动传入依赖
2. watchEffect 会先执行一次用来自动收集依赖
3. watchEffect 无法获取到变化前的值， 只能获取变化后的值

::: danger
留一个思考题： 如果定义一个非响应式的值， watch和watchEffect可以监听到值的变化吗？
:::



模块化使用1：
自定义hooks文件， 存放抽离出来的逻辑文件比如`useMousePosition`
```javascript
function useMousePosition(){
    const x = ref(0)
    const y = ref(0)

    const updateMouse = (e: MouseEvent) =>{
        x.value = e.pageX
        y.value = e.pageY
    }
    onMounted(() =>{
        document.addEventListener('click', updateMouse)
    })
    onUnmounted(() =>{
        document.removeEventListener('click', updateMouse)
    })

    return { x, y}
}
export default useMousePosition
```

模块化使用2：

## Teleport
新推出的功能
瞬间移动
Teleport 包裹的的组件
```vue
<teleport to="modal">
    <div>model组件</div>
</teleport>
```

## Suspense
异步
```
<Suspense>
    <template #default>
        <async-await></async-await>
    </template>
     <template #fallback>
        <div>loading...</div>
    </template>
</Suspense>
```

## 虚拟DOM的底层原理

## 更好的 TreeShaking 
nextTick 不再绑定到Vue上， 而是具名函数导入

## Typescript支持
vue2对于 typescript 的支持非常有限
之前使用vue2是使用 vue class的写法或者vue extends 来集成对typescript的支持


vue3 :
```typescript
import {defineComponent} from 'vue'

const component = 
defineComponent({
    name: 'HelloWorld',
    props: {
        msg: String
    },
    setup(props, context){
        // 有两个参数 props 可以访问组件传入的属性
        // context 提供vue上最常用的属性（attrs, slots, emit）, 这几个值都是自动同步最新的值
    }
})
```



参考：慕课网vue3.0+typescript开发知乎专栏

https://juejin.im/post/6867123074148335624#heading-4

https://juejin.im/post/6844904200162246669#heading-3


https://juejin.im/post/6844904066103902215#heading-9