---
title: 时间复杂度与空间复杂度
date: 2019-02-21 12:20:10
permalink: /pages/79693743
categories: 
  - 算法
  - 数据结构
tags: 
  - 时间复杂度
  - 空间复杂度
author: 
  name: fanfan
  link: 
---

很多小伙伴和我一样面试时往往不希望被问到的就是算法题，总觉得算法比较困难，不可攻克；最近我在学习算法， 所以将自己学习的一些心得体会写下来， 希望也能帮到大家。
 
要学习算法， 首先我们要知道算法究竟是什么？ 官方定义：指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。（内心diss：说的是人话吗？虽然是很短的一段，但是还是不想记。。）我通俗的理解， 算法其实是**解决某个问题的计算方法、步骤**。比如小学的乘法算法表，七七四十九...

## 算法执行效率
既然算法能解决问题，那么每个人针对同一个问题都可能有不同的解决方案，解决问题的办法就多样化起来，那哪个算法才是最好的，更有效的呢？
主要还是从算法所占用的「时间」和「空间」两个维度来考量。
很多时候一个优秀的算法就在于它与其他解决同一个问题的算法相比， 在时间或者空间（内存）亦或者二者都得到明显的降低。

所以算法的效率主要有以下两个复杂度来评估：

`时间复杂度`：评估执行程序所需要的时间。可以估算出程序对处理器的使用程度。

`空间复杂度`：评估执行程序所需要的存储空间。可以估算出程序对计算机内存的使用程度。

所以我们在设计算法的时候就要考虑时间复杂度和空间复杂度，然而在时间与空间是鱼与熊掌不可兼得，那我们就要取一个平衡点。其实我们在设计算法时的很多时候都用到一个思想**用空间换时间**

下面分别为大家介绍一下「时间复杂度」和「空间复杂度」的计算方式

## 时间复杂度
一个算法执行的所耗时间，从理论上是不能算出来的， 有的小伙伴就说啦！我在机器上运行一下不就知道啦！这种方式当然可以， 但是由于局限性， 电脑配置不同，使用的工具不同跑出来的结果相差会很大， 而且和你输入的测试数据量级也是有很大关系。

其实我们只需要知道哪个算法花费的时间多，哪个算法花费的时间少就可以了，算法耗时和语句的执行次数是成正比的，即语句执行次数越多，耗时越多，因此我们采用一种「大O表示法」来表示时间复杂度。


话不多说，举个栗子来认识「大O表示法」：
```javascript
let num = 0
for (let i = 0; i < n; i++ ) {
    num += i;
}
```
用「大O表示法」我们说这个算法的时间复杂度为O(n)，怎么来的呢？

大O表示法中，时间复杂度的公式是： T(n) = O(f(n)), f(n)函数表示每行代码执行次数之和，而O表示正比例关系， 这个公式的称为：**算法的渐进时间复杂度**， 简称时间复杂度。

上面例子中， 假设每行代码执行的时间都是一样的，那么第一行执行次数是1，第二行执行次数为n, 第三行执行次数也为n， 所以fn = 1 + n + n = 2n + 1。从这个结果看得出来，这个算法中**操作次数和n正比线性增长**

「大O表示法」并不是用于计算真实执行时间，而是表示一种变化趋势。当n无限大时， 常数1和倍数2意义就不大了，因此我们简化的将这个算法时间复杂度表示为： **O(n)**


从上面大家可能理解了大O表示法的分析方式，接下来我们分析一下几种常见的时间复杂度实例，加深一下印象。

## 常见的时间复杂
列举一些简单例子的时间复杂度。
常见的时间复杂度量级是：
- O(1): 常数阶
- O(log n): 对数阶
- O(n):  线性阶
- O(nlogN)： 线性对数阶
- O(n^2): 平方阶； O(n^3): 立方阶； O(n^k) k次方阶
- O(2^n):指数阶
- O(n!):阶乘阶

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。下图为时间复杂度的曲线图，可以非常直观的看到，O(2^n)和O(n!)的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，他们复杂度的算法其实是非常低效的算法。

![](https://user-gold-cdn.xitu.io/2020/4/25/171afd9df4fdce91?w=741&h=754&f=png&s=51364)


###  常数阶O(1)
我们需要知道，O(1)是常数级复杂度的一种表示方法， 并不是指只执行一行代码，无论执行多少行代码，只要是没有循环等复杂结构时间复杂度就是O(1)。比如这段代码：
```javascript
let a = 1;
a++ ;
console.log('a的值：', a);
```
上面这段代码在执行时， 它消耗的时间并随着某个变量的增长而增长， 即使它有成千上万条操作，也只是个较大的常数，这类时间复杂度为O(1)

线性阶O(n)，在上面举例中已经学习了， 这里就不赘述， 直接看O(logn) 与 线性对数阶O(nlog(n))


### 对数阶O(logn) 与 线性对数阶O(nlog(n))
对数阶时间复杂度非常常见， 我们先看一段代码：
```javascript
let num = 1;
while(num <= n ){
    num = num * 2
}
```
根据我们前面时间复杂度的分析方法， 第三行代码循环执行次数最多，所以只要算出这行代码被执行多少次，就能知道时间复杂度。
变量从num=1开始取值， 每循环一次就乘以2, 当`num > n` 时,循环结束。num变化的过程列出来其实是这个样子：

2<sup>0</sup>
2<sup>1</sup>
2<sup>2</sup>
2<sup>3</sup>
2<sup>4</sup>
...
2<sup>x</sup>

当代码执行x次时， 2<sup>x</sup>= n; 所以x = log<sub>2</sub>n

也就是说当循环 log<sub>2</sub>n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

> 注意：不管是log<sub>2</sub>n 还是 log<sub>3</sub>n, 或者是 log<sub>10</sub>n， 我们都把时间复杂度记为**O(logn)**， 在采用「大O表示法」描述时间复杂度时， 我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。

在理解了O(n)和O(logn)的基础上， 就非常的容易理解O(nlogN)了，我们看下面这段代码：
```javascript
for(let i = 0; i < n; i++ ){
    let j = 0
    while(j < n ){
        j = j * 3
    }
}
```

其实就是复杂度为O(logn)的代码，再循环n次执行， 时间复杂度就是O(nlogN)

### 平方阶O(n<sup>2</sup>)
平方阶也很容易理解， 将O(n)的代码再嵌套循环执行n次，就是O(n * n) 时间复杂度为O(n<sup>2</sup>)

代码：
```javascript
for(let i = 0; i < n; i++){
    for(let j = 0; j < n; j++){
        console.log('i与j的值:',i, j);
    }
}
```
如果其中一层循环次数由n变成m, 那时间复杂度就变成了O(n * m)

至于立方阶O(n<sup>3</sup>)和K次方阶O(n<sup>k</sup>), 同O(n<sup>2</sup>)的方式去理解就可以了。


###  指数阶 O(2<sup>n</sup>) 
前面页说到了O(2^n)和O(n!)的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，他们复杂度的算法其实是非常低效的算法， 所以我们会尽量避免设计出这样的算法，下面我们先来认识什么样的程序会是 O(2<sup>n</sup>)

> 需求：求斐波拉契数列的第n项, 
Fib: 0, 1, 1, 2, 3, 5, 8, 13, 21, ......
>
> 通项公式：F(n) = F(n-1) + F(n-2)

直接使用递归代码实现:
```javascript
function fib(n){
    if(n <=1) return n
    return fib(n -1) + fib(n-2)
}
```
我们在看递归方法时， 就是要看递归这个这个语句总共执行了多少次


![](https://user-gold-cdn.xitu.io/2020/4/25/171b080005935d0c?w=1029&h=516&f=png&s=49141)

当求解第7项斐波拉契数列时，我们将程序执行过程绘制成树状结构分析，从图中我们可以看到， 每多展开一层，运行的节点数就是上面的两倍，所以节点数是在按指数级增长的， 当我们到n级时，就是大概2<sup>n</sup>这么一个数量级的节点，所以我们说这个程序的时间复杂度是o(2<sup>n</sup>)

上面我们也提到了，如果设计出来这样一个算法，它的执行效率其实是很低的，那我们就要考虑了，能不能进行有优化呢， 降低它的时间复杂度。

接下来我们进一步分析这个图，在绘制图时，我故意将相同求值用同一个颜色标记，这样 就很容易发现F(5)、F(4)、F(3)等数被多次求解，所以才导致求解一个F(7),需要执行这么多次。那我们可不可以将这些中间结果缓存下来，或者说使用循环来实现；在这里这大家留一个思考题， 后面关于动态规划的算法题分析时，我会将这道题作为例子分析讲解


## 空间复杂度
空间复杂度的推算和时间复杂度类似，唯一不同的是，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度没有时间复杂度那么复杂，比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

### 空间复杂度O(1)
如果算法执行所需要的临时空间不随某个变量n的大小而变化，即算法空间复杂度为一个常量，可以表示为O(1)
```javascript
let sum =0;
for(let i=0;i < n; i++){
    sum += i
}
```
O(1)是说数据规模和临时变量数目无关， 并不是说仅仅定义一个临时变量。比如上面的例子，不管n数量级多大， 也只有两个变量，所以所上面代码的空间复杂度为O(1)

### 空间复杂度O(n)
再来看一段代码：
```javascript
function initArr(n) {
  let arr = [];      // 第2行
  for (let i = 0; i < n; i++) {  
    arr[i]= i;       // 第4行
  }
  for(let j = n - 1; j >= n; --j){
      console.log(arr[j])
  }
}
```
和时间复杂度分析一样，我们可以看到在第二行代码中，申请了一个空存储变量arr,是一个空数组，然后每循环执行第4行，arr的长度就增加一次，随着n的变化而变化， 其他代码都没有占用更多的空间，所以整段代码的空间复杂度为O(n)

## 总结
关于时间复杂度和空间复杂度的学习在这里就告一段落了， 我们做一个简单的总结：
复杂度也叫**渐进复杂度**， 包括时间复杂度和空间复杂度，常见得时间复杂度有：
- O(1): 常数阶
- O(log n): 对数阶
- O(n):  线性阶
- O(nlogN)： 线性对数阶
- O(n<sup>2</sup>) : 平方阶； O(n<sup>3</sup>): 立方阶； O(n<sup>k</sup>) k次方阶
- O(2^n):指数阶
- O(n!):阶乘阶

时间算法复杂度关系为：O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) <O(n!)

常见的空间复杂度为：
- O(1)
- O(n)
- O(n<sup>2</sup>)

到后面我们做的算法题中，就会发现，机会所以的算法复杂度都在这个范畴。

最后我们举几个例子来看看如何从时间复杂度和空间复杂度着手优化算法。
>需求：实现累加： `1+2+3+4+...+n`
```javascript
function total(n) {
      var sum = 0;
      for (var i = 1; i < n; i++) {
        sum += i;
      }
      return sum;
    }
```
上面的代码是采用从头到尾累加的方式实现的， 分析上面代码：
- 时间复杂度： O(n)
- 空间复杂度: O(1)

我们在数学上还学习了一种计算方式， 就是首位相加在除以2：
```
(1+n)+(2+n-1)+(3+n-2)+ ...  => (n+1)n / 2
```
代码实现如下：
```javascript
let sum =0
function total(n){
    sum = n * (n + 1) / 2
    return sum
}
```
时间复杂度由O(n)变成O(1)， 在空间上虽然还是O(1),但是其实也是省了一个变量空间的。

后面还有更多关于算法的解法以及优化思路， 欢迎大家关注「前端饭圈」

下一章节将为大家介绍数据结构，比如数组、链表等，以及它们的常用操作的时间复杂度分别是多少。


参考文章：

https://juejin.im/post/58d15f1044d90400691834d4


https://zhuanlan.zhihu.com/p/50479555